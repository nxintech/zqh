倒水问题
-----------
假设有2个容量不同的水杯，一个是4L另一个是9L，还有一个无限容量的水源可以向任意的杯子倒水。我们的目标是利用这2个水杯得到特定容量的水，
例如6L。这里的水杯上是没有刻度的，所以无法通过不倒满杯子就能精确地得到6L水。

如何解决这个问题呢？假如我们的目标是得到5L的水，那么这个问题显然就简单多了。我们可以先倒满9L的杯子，
然后从9L杯子向4L杯子倒水，直到4L杯子满了，这时候9L杯子里应该还剩5L的水。

想得到6L水没有那么明显的方法，但是前面的解决方法给出了解题思路，这个问题的本质是根据给定目标，找出一个倒水动作的序列。
这里的倒水动作可以是从水源向杯子倒水，也可是从杯子向另一个杯子倒水，甚至可以是将杯子中的水倒在地上，这样我们就有了6种倒水动作。
目标就是找出这6种动作的序列以得到6L水。当然水杯的容量在这里也应该是一个抽象的概念，我们可以任意设定水杯的容量，
所以我们要设定一个描述水杯的概念，如容量V和当前水位C，9L杯子里剩5L的水，我们可以说杯子的容量V=9，C=5。

9L杯子向4L杯子倒水的动作结束之后，每个杯子的当前水位是(4,5)，我们可以认为这是一个状态，
那么现在我们有了动作--1，2，3，4，5，6，有了状态(4,5)，这个问题就变成了找到从状态(0,0)到另一种状态(x,6)所经过的动作的序列。

问题的复杂性
--------
我们仅仅知道了我们所要寻找的状态，但我们并不知道这期间需要多少次倒水动作，也就是说序列长度是无法预计的。
在处在每个状态时，我们都有6种不同的动作可以选择，而且我们知道最终状态应该是6和一个值，但是我们不知道x应该是多少，
这个问题可以叫做"搜索"问题。

探索空间
------
我们知道了起点(0,0)，然后展开探索，一种方法是可以倒满其中一个杯子，这样就达到了另一个状态(4,0)，当然可以倒满另一个杯子，
这是另一个选择的方向，每种选择都像是从当前状态延伸出去的分支，可能在某个分支上会出现其他分支的状态，也就是说这个状态我们之前探索过了。
我们知道电脑内存可以存储很多的状态，但是一个探索过的状态我们没有必要进行重复的劳动，应该具有某种回退机制，返回上一个状态，重新做一个新的选择。

还有2点需要注意，第一个就是也许根本没有答案，即没有路径从起始状态可以到达目标状态，所以我们希望探索过程中是可以反馈出任务是不可能完成的，
而不是傻傻的无尽的寻找下去。
第二个问题就是，如果有某种路径可以达到目标，我们希望它是在合理的时间内的，也就说找出效率最高的那条路径，而不是卡在无尽的循环里。
例如从x向y倒水，在从y向x倒水，如此循环几次，可能最终我们会到达目标，但是这中间的过程是不必要的，所以这里的策略至少应该是不能让状态进行回退，
就是说如果之前是从状态A到B，那么我们不能再从B回到A。

解决问题
---------
经过上面的探讨之后，我们来coding it up

```
def pour_problem(X, Y, goal, start = (0, 0)):
    
```