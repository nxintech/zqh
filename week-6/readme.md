二叉搜索树
-----
Binary Search Tree BST

性质

* 左子树的所有节点小于当前节点。
* 右子树的所有节点大于当前节点。


这个定义非常简单，一句话就是左孩子比父节点小，右孩子比父节点大。

还有一个特性就是”中序遍历“可以得到有序的结果。
 
插入节点
----

```
[20, 15, 25, 18, 10, 12, 30]
```

首先插入20，此时树只有一个节点，下图最左边

接着插入15， 15小于20，放在20左节点，下图中间

接着插入25， 25 大于20，放在右边， 下图右边

![](bst1.png)

然后继续插入 18， 18小于20，走左边，左边已经有15了，18 比 15大，所以18 放在 15右边
![](bst2.png)

接着插入10，10小于20，走左边，10小于15，放在15左边
![](bst3.png)

后面就不继续了，总之很简单，最终得到BST树
![](bst4.png)


通过观察BST可以发现，最小值在最左边，最大值在最右边

排序就是中序遍历

删除元素
---
假设我们要删除元素15，下面列出排序数组中15的位置

![](bst5.png)

因为中序遍历数组是有序的，我们仅需将前一个节点或者后一个节点移动到删除节点的位置上即可。

体现在图中就是这样
![](bst6.png)

无论移动哪个节点，最终的树都满足BST的性质，大家根据喜好选择
![](bst7.png)


BST最大的问题就是，如果插入顺序有序，就变成了线型查找树。

![](bst8.png)

在节点左右分布均匀的情况下，查找的效率是O(logN)，而线型情况下是O(N)


所以二叉查找树不是严格的O(logN)。


AVL树
----
平衡二叉树，AVL树是根据它的发明者G. M. **A**delson-**V**elskii和E. M. **L**andis命名的。

它是一种特殊的二叉搜索树。主要解决上面提到的BST不够"平衡"的问题。使得查找的时间尽量接近O(logN)。

介绍性质前，需要先介绍一个概念：节点高度

所谓节点的高度就是， 当前节点到子叶节点的最长路径的长度，为了更好的理解这个概念，这里我对节点进行高度的标记。

首先一个子叶节点自己到自己的路径没有经过任何节点，所以高度为0

那么只有1个子叶节点的根节点的高度显然为1

![](avl1.png)

下图一个BST树的各个节点的高度
![](avl2.png)

假如我们用h(n)表示节点n的高度，那么通过观察上图，不难发现其高度是，左右子树根节点高度的最大值加1,即
```
h(n) = max(h(n.left), h(n.right)) + 1
```

AVL除了满足所有BST性质外，还要满足一个性质，这个性质和节点高度有关

性质：任一节点的左子树节点高度和右子树节点高度相差不超过1。

```
|h(n.left) - h(n.right)| <= 1 
```


所以当一个AVL树高度h时 左右子树要么高度都是h-1,要么一个是h-1，一个是h-2

如果一个节点的左右子树节点高度的差值大于1，我们就认为这个节点失衡了。

插入
---
既然AVL树是BST树，那么插入时必然要满足BST插入的性质，
![](avl3.png)
插入完成后，刚好满足性质，例如插入5
![](avl6.png)

也有可能插入完成后节点高度产生了变化，新树有可能会不满足AVL的性质，例如插入11
![](avl4.png)

注意图中画圈的两个节点，这时我们发现节点15失衡了。

那么如何调整这个树，使它保持AVL的性质？请看下文

旋转 rotation
-----------
恩，这个词很贴切，我们知道一个人转多了会晕，树也是如此，转多了人也会晕。

官方的做法是进行左旋和右旋，但是说实话这个不太好理解，我也不明白为什么。

所以今天我想了一下这个问题，这里我就讲一下我自己的理解，不一定正确，大家先看看说的有没有道理。

首先我们单独拿出这个失衡的树，如图
![](avl5.png)

因为左右子树高度差值大于1了，那么最直接的办法就是去调整子树的高度，使得差值小于等于1。


既然是调整子树高度，使得差值小于等于1，那么显然有3种选择
* 把左边高度减去1，右边不变。
* 左边减去1，右边高度加1。
* 左边不变，右边高度加1

